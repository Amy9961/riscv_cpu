# 名词解释

#### RT-Thread

一个开源的实时操作系统（RTOS），面向嵌入式系统领域，适用于资源受限的硬件平台（如MCU）（因为我们做的CPU过于简单）

#### 单周期 vs 流水线

单周期：每条指令在一个时钟周期内完成，控制逻辑简单，适合教学或简单CPU

流水线：将指令拆分为多个阶段，每个阶段由专用硬件并行处理

- 运行RISC-V，单周期CPU可以设计为支持RISC-V的基础指令（如RV32I），但复杂指令（如乘除法、原子操作）需要额外周期或硬件支持。

#### cache

集成在处理器内部的高速存储器，用于**临时存储CPU频繁使用的指令和数据**，以解决CPU与内存之间的速度差异（避免CPU因等待数据而“空转”）

#### 总线

连接CPU与其他硬件（内存、芯片组、外设等）的高速通道，负责传输数据、地址和控制信号

#### **SVH文件**

（通常以 `.svh` 为后缀）是 **SystemVerilog 头文件**（SystemVerilog Header），用于存储可复用的 SystemVerilog 代码片段（如宏定义、参数、类型声明、函数/任务等），类似于 C/C++ 中的 `.h` 头文件。

#### 仿真

对CPU（如开源RISC-V核**SCR1**）进行仿真是芯片设计流程中的关键环节，包括验证功能正确性（确保指令集兼容、逻辑错误检测、验证中断）、性能评估与优化（流水线效率、缓存内存访问）、硬件-软件协同验证（运行真实软件、调试工具链）

# 基础知识

## 计算机体系结构

### CPU如何执行任务？

一条指令在CPU中的执行过程通常分为五个基本阶段，称为指令流水线，包括**取指→译码→执行→访存→写回**五个阶段

**1.取指（Instruction Fetch, IF）**

从**内存**或**指令缓存（L1 Cache）**中读取下一条指令。

关键操作：

- 程序计数器（PC）提供指令地址。
- 通过总线从内存/缓存加载指令到**指令寄存器（IR）**。
- PC自动更新，指向下一条指令地址（PC+4，假设指令长度为4字节）。

**2. 译码（Instruction Decode, ID）**

解析指令，确定操作类型和操作数。

关键操作：

- 拆解指令的**操作码（Opcode）**，确定操作类型（如加法、跳转）。
- 读取寄存器文件（Register File）中的操作数（如`R1`、`R2`的值）。
- 解析立即数（Immediate）或地址偏移量（用于访存或跳转指令）。

**3. 执行（Execute, EX）**

执行指令的实际计算或逻辑操作。

关键操作：

- **算术/逻辑指令**：由ALU（算术逻辑单元）完成计算（如`ADD R1, R2, R3`）。
- **访存指令**：计算内存地址（如`LW R1, 100(R2)`中的`100+R2`）。
- **分支指令**：比较条件并计算目标地址（如`BEQ R1, R2, Label`）。

**4. 访存（Memory Access, MEM）**

仅访存指令（Load/Store）需要此阶段，读写数据内存。

关键操作

- **Load指令**：从内存读取数据到寄存器（如`LW R1, 0(R2)`）。
- **Store指令**：将寄存器数据写入内存（如`SW R1, 0(R2)`）。
- 其他指令（如算术指令）在此阶段**空转（NOP）**。

**5. 写回（Write Back, WB）**

将执行结果写回寄存器文件。

关键操作：

- **算术/逻辑指令**：将ALU结果写入目标寄存器（如`ADD R3, R1, R2`的结果写回`R3`）。
- **Load指令**：将内存读取的数据写入目标寄存器。
- 分支或Store指令**无需写回**。

-----

### CPU的种类

在CPU设计中，**单周期（Single-Cycle）**和**多周期（Multi-Cycle）**是两种与流水线（Pipeline）不同的指令执行方式。它们的核心差异在于**指令执行的时间分配和硬件资源利用率**。以下是它们的对比分析：

**1. 单周期（Single-Cycle）CPU**

**特点**

- **每条指令在一个时钟周期内完成**，无论指令类型（简单加法 or 复杂访存）。
- **时钟周期必须足够长**，以覆盖最慢指令的执行时间（如`LOAD`需要访存）。
- **硬件简单**，但效率极低（大部分时间浪费在等待慢速操作）。

**执行流程**

1. **取指（IF）**：从内存读取指令。
2. **译码（ID）**：解析指令，准备操作数。
3. **执行（EX）**：ALU计算或地址计算。
4. **访存（MEM）**（仅`LOAD/STORE`需要）。
5. **写回（WB）**：结果写回寄存器。

**示例**

假设：

- 加法指令（`ADD`）耗时 **2ns**。
- 访存指令（`LOAD`）耗时 **10ns**（最慢）。
- 时钟周期必须设为 **10ns**（适配`LOAD`），导致`ADD`浪费 **8ns**。

**优缺点**

|       **优点**       |            **缺点**             |
| :------------------: | :-----------------------------: |
|     控制逻辑简单     | 效率极低（CPI=1，但时钟频率低） |
|     无流水线冲突     |        无法并行执行指令         |
| 适合教学或低功耗场景 |       性能受限于最慢指令        |

**2. 多周期（Multi-Cycle）CPU**

**特点**

- **每条指令拆分为多个固定小步骤**，每个步骤占用**一个时钟周期**。
- **时钟周期较短**（按最慢的**单一步骤**设定，而非最慢指令）。
- **共享硬件资源**（如ALU在多个阶段复用），减少冗余电路。

**执行流程**

每条指令的周期数可变（例如）：

- `ADD`：**4个周期**（IF→ID→EX→WB）。
- `LOAD`：**5个周期**（IF→ID→EX→MEM→WB）。

**示例**

假设：

- 每个小步骤（如取指、ALU计算）耗时 **2ns**。
- `ADD`需要 **4×2ns=8ns**，`LOAD`需要 **5×2ns=10ns**。
- **时钟周期=2ns**（比单周期的10ns快5倍）。

**优缺点**

|    **优点**    |             **缺点**             |
| :------------: | :------------------------------: |
|  时钟频率更高  |          控制逻辑更复杂          |
| 硬件利用率提升 | 仍有部分空闲周期（无法完全并行） |
| 比单周期更高效 |         性能仍不如流水线         |

**3. 流水线（Pipeline）CPU**

**特点**

- **指令执行重叠**：不同指令的不同阶段**并行执行**（如指令1在EX时，指令2在ID）。
- **时钟周期短**（按最慢的**单一级别**设定，如访存阶段）。
- **理想CPI≈1**（每个时钟周期完成一条指令）。

**执行流程**

经典五级流水线（MIPS）：

```
周期1: IF(指令1) → ID(空) → EX(空) → MEM(空) → WB(空)  
周期2: IF(指令2) → ID(指令1) → EX(空) → MEM(空) → WB(空)  
周期3: IF(指令3) → ID(指令2) → EX(指令1) → MEM(空) → WB(空)  
...
周期5: IF(指令5) → ID(指令4) → EX(指令3) → MEM(指令2) → WB(指令1)  
```

> ✅ **理想情况**：每个周期有一条指令完成（吞吐量=1 IPC）。

**优缺点**

|       **优点**       |                   **缺点**                   |
| :------------------: | :------------------------------------------: |
| 高吞吐量（IPC接近1） | 需要处理**流水线冲突**（数据/控制/结构冒险） |
|      时钟频率高      |      硬件复杂度高（需转发、分支预测等）      |
|    现代CPU的标配     |        深度流水线增加分支预测失败代价        |

**4. 对比总结**

| **设计方式** | **时钟周期长度** | **CPI（Cycles Per Instruction）** | **硬件复杂度** |     **适用场景**     |
| :----------: | :--------------: | :-------------------------------: | :------------: | :------------------: |
|  **单周期**  |  按最慢指令设定  |   CPI=1（但频率低，实际性能差）   |      最低      | 教学、简单嵌入式系统 |
|  **多周期**  |  按最慢阶段设定  |       CPI=4~5（但频率更高）       |      中等      | 早期处理器（如MIPS） |
|  **流水线**  |  按最慢阶段设定  |         CPI≈1（理想情况）         |      最高      |  现代CPU（x86/ARM）  |

**关键问题与解决方案**

**(1) 流水线冲突**

- 

  数据冒险

  ：后续指令依赖前一条指令的结果。

  - **解决**：旁路（Forwarding/Bypassing）直接传递ALU结果，避免等待写回。

- 

  控制冒险

  ：分支指令导致后续指令无效。

  - **解决**：分支预测（Branch Prediction）提前猜测跳转方向。

- 

  结构冒险

  ：硬件资源冲突（如同时访存和取指）。

  - **解决**：分离缓存（哈佛架构）或增加资源。

**(2) 为什么现代CPU不用单周期/多周期？**

- **单周期**：时钟频率太低，无法满足性能需求。
- **多周期**：虽比单周期快，但无法充分利用指令级并行（ILP）。
- **流水线**：通过并行最大化吞吐量，尽管需要复杂冲突处理。

**总结**

- **单周期**：简单但低效，适合教学。
- **多周期**：折中方案，早期商用CPU使用（如MIPS R2000）。
- **流水线**：现代CPU的核心设计，通过**并行+冲突优化**实现高性能。

**类比**：

- **单周期** → 一个人从头到尾做一道菜（慢）。
- **多周期** → 一个人分步骤做菜（快一点）。
- **流水线** → 流水线厨师（切菜、炒菜、装盘并行，最快）。

----------





